{
  "270handout": [
    {
      "summary": "This document discusses dynamic programming solutions for two optimization problems: the coin changing problem (finding the minimum number of coins to make a target sum) and the assembly-line scheduling problem (finding the shortest path through manufacturing stations), both involving recursive decision-making and optimal substructure.",
      "key_concept": "Dynamic Programming",
      "path": "270handout/270handout7 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This document explores various graph problem transformations, including bipartite matching, circulations, survey design, and baseball elimination, demonstrating how different computational problems can be reduced to network flow and solved efficiently in polynomial time.",
      "key_concept": "Network Flow",
      "path": "270handout/270handout21.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses polynomial-time reductions in computer science, specifically demonstrating how problems like Minimum Cut, Bipartite Matching, and Circulations can be solved efficiently by transforming them into network flow problems using algorithmic techniques.",
      "key_concept": "Poly-Time Reductions",
      "path": "270handout/270handout20.pdf",
      "category": "handout"
    },
    {
      "summary": "Dynamic Programming is a problem-solving technique that transforms recursive algorithms into iterative solutions by systematically breaking down complex problems into simpler subproblems and storing intermediate results to avoid redundant computations, illustrated through examples like calculating Fibonacci numbers and solving the Weighted Interval Scheduling problem.",
      "key_concept": "Dynamic Programming",
      "path": "270handout/270handout5 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses a project selection problem where the goal is to find the maximum-valued subset of projects with prerequisites, using graph-based techniques and min-cut analysis to optimize project selection while considering project values and dependencies.",
      "key_concept": "Graph Reduction",
      "path": "270handout/270handout22.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture notes discuss greedy algorithms, focusing on techniques for solving problems like all-pairs shortest paths and interval scheduling, with an emphasis on proving algorithm correctness through inductive reasoning and sequential decision-making.",
      "key_concept": "Greedy Algorithms",
      "path": "270handout/270handout10 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This document explores the concept of NP-completeness by discussing computational complexity, introducing problems like Independent Set and Vertex Cover, and explaining how Circuit-SAT serves as a fundamental NP-complete problem that can potentially reduce all NP problems to a polynomial-time verifiable solution.",
      "key_concept": "NP-Completeness",
      "path": "270handout/270handout23.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses an advanced caching problem where the goal is to minimize cache misses by strategically deciding which items to remove from a cache with a fixed capacity when new items are requested, exploring potential greedy algorithms and their limitations.",
      "key_concept": "Optimal Caching",
      "path": "270handout/270handout15 (2).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture on graph algorithms explores concepts of graph connectivity, directed acyclic graphs (DAGs), topological ordering, and related algorithmic challenges in graph theory.",
      "key_concept": "Graph Connectivity",
      "path": "270handout/270handout4 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture covers several computational complexity problems, including the Travelling Salesman Problem, Subset Sum, and graph coloring challenges like 3-Color and 4-Color, which involve finding optimal solutions or determining the feasibility of specific constraints.",
      "key_concept": "NP-Completeness",
      "path": "270handout/270handout27.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture discusses sequencing problems like the Travelling Salesman Problem and Longest Path, exploring the characteristics of NP-complete problems and highlighting that the complexity of a problem can vary significantly depending on its specific constraints.",
      "key_concept": "NP-completeness",
      "path": "270handout/270handout26.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses two main algorithmic topics: sequence alignment (specifically an efficient method for calculating edit distance between strings using divide-and-conquer) and network flow (exploring the max-flow min-cut problem and the Ford-Fulkerson algorithm for finding augmenting paths in a residual graph).",
      "key_concept": "Network Flow",
      "path": "270handout/270handout18 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture covers advanced computer science topics including the Post Correspondence Problem (PCP), its connection to the Halting Problem, and an exploration of computational complexity classes like PSPACE, with a focus on demonstrating the complexity of problems such as determining the truth of fully quantified Boolean formulas.",
      "key_concept": "Post Correspondence Problem (PCP)",
      "path": "270handout/270handout30.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture discusses NP-Complete problems, focusing on 3-SAT, Independent Set, Set Packing, and k-Clique, while exploring their relationships and the broader implications for understanding computational complexity and the P vs NP problem.",
      "key_concept": "NP-Completeness",
      "path": "270handout/270handout24.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses various NP-complete problems like Independent Set, Set Packing, k-Clique, and Hamiltonian Cycle, highlighting the complexity of these problems and the ongoing challenge of proving whether P equals NP.",
      "key_concept": "NP-Completeness",
      "path": "270handout/270handout25.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses network flow algorithms, specifically the Ford-Fulkerson method for finding the maximum flow in a weighted directed graph, including concepts like residual graphs, augmenting paths, the max-flow min-cut theorem, and capacity-scaling techniques.",
      "key_concept": "Network Flow",
      "path": "270handout/270handout19.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses algorithmic approaches to scheduling tasks with deadlines to minimize lateness and explores optimal caching strategies, focusing on greedy algorithms and proof techniques for minimizing task tardiness and cache misses.",
      "key_concept": "Greedy Algorithms",
      "path": "270handout/270handout14.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses theoretical computer science concepts including 3-D matching, the Halting Problem, the Barber Paradox, and the comparison of countable and uncountable infinite sets, highlighting fundamental challenges in computational theory and mathematical logic.",
      "key_concept": "Halting Problem",
      "path": "270handout/270handout28.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture explores the limits of computation by discussing the Halting Problem, demonstrating through diagonalization and a self-referential paradox that certain computational problems are undecidable, specifically showing that it's impossible to create a universal algorithm that can determine whether an arbitrary computer program will halt or enter an infinite loop.",
      "key_concept": "Undecidability",
      "path": "270handout/270handout29.pdf",
      "category": "handout"
    },
    {
      "summary": "This document covers two dynamic programming algorithms in computer science: sequence alignment (edit distance between strings) and RNA secondary structure prediction, both focusing on efficiently solving optimization problems by breaking them down into smaller subproblems and using recursive techniques.",
      "key_concept": "Dynamic Programming",
      "path": "270handout/270handout8 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture notes discuss the Longest Increasing Subsequence (LIS) problem, exploring recursive approaches to finding the longest increasing subsequence in a given sequence of numbers, and briefly touching on polynomial runtime algorithms and primality testing.",
      "key_concept": "Dynamic Programming",
      "path": "270handout/270handout6.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture covers amortized runtime analysis, exploring the performance characteristics of list operations, binary counting, and minimum spanning tree algorithms like Kruskal's and Prim's, with a focus on understanding the average-case computational complexity of various algorithmic operations.",
      "key_concept": "Amortized Runtime Analysis",
      "path": "270handout/270handout2.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses common proof errors when attempting to prove the correctness of Prim's Algorithm, and provides a detailed, step-by-step correct proof methodology for demonstrating that the algorithm produces an optimal minimum spanning tree.",
      "key_concept": "Proof by Induction",
      "path": "270handout/270handout12.pdf",
      "category": "handout"
    },
    {
      "summary": "This document describes a classroom exercise for CSCI 270 where students practice creating and grading proofs for a greedy algorithm that forms study groups with a specific composition of students and course participants (CPs).",
      "key_concept": "Proof Techniques",
      "path": "270handout/270handout13.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture introduces fundamental computer science concepts including algorithm design, problem-solving strategies, the famous person problem, stable matching algorithms, and the ethical considerations of algorithmic decision-making, with a focus on developing systematic approaches to solving computational challenges.",
      "key_concept": "Algorithms",
      "path": "270handout/270handout1.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses greedy algorithm design and proof techniques, specifically focusing on interval scheduling and minimum spanning tree algorithms, demonstrating how to prove the correctness of greedy algorithms using inductive reasoning and exchange arguments.",
      "key_concept": "Greedy Algorithms",
      "path": "270handout/270handout11.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture notes discuss two dynamic programming algorithms: the Subset Sum problem for determining if a subset of integers can sum to a target value, and the Shortest Path problem (Bellman-Ford algorithm) for finding the shortest path in a graph with no negative weight cycles.",
      "key_concept": "Dynamic Programming",
      "path": "270handout/270handout9 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture notes document covers three divide and conquer algorithms: All Pairs Shortest Paths, Integer Multiplication, and Closest Points on a Plane, exploring their recursive strategies, base cases, recurrence relations, and computational complexities.",
      "key_concept": "Divide and Conquer",
      "path": "270handout/270handout17 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture on Divide and Conquer explores a runtime improvement technique that involves splitting problems into smaller, independent subproblems, solving them recursively, and then combining the results, with a focus on understanding its principles, analyzing algorithms like counting inversions, and applying the Master Theorem to solve recurrence relations.",
      "key_concept": "Divide and Conquer",
      "path": "270handout/270handout16 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture notes document covers Union-Find data structures, Kruskal's algorithm for minimum spanning trees, sorting algorithm complexity (including comparison-based sorting lower bounds), and graph theory concepts like bipartite graphs.",
      "key_concept": "Union-Find",
      "path": "270handout/270handout3 (1).pdf",
      "category": "handout"
    }
  ],
  "270questions": [
    {
      "summary": "This is a computer science homework assignment (CSCI 270) containing four algorithmic problem-solving challenges involving graph partitioning, dynamic programming for frog hopping, palindrome substring detection, and a game theory problem with a linked list.",
      "key_concept": "Dynamic Programming",
      "path": "270questions/270HW3.pdf",
      "category": "question"
    },
    {
      "summary": "This homework assignment for CSCI 270 covers advanced data structure problems involving stacks, queues, amortized analysis, and sorting algorithms, with specific challenges related to stack/queue operations, sequence validation, and k-sorted array sorting.",
      "key_concept": "Data Structures",
      "path": "270questions/270HW2.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment (CSCI 270) containing four problems that cover topics in algorithm analysis, asymptotic complexity, mathematical proofs by contradiction and induction, involving function comparisons, big O notation, and graph/location connectivity problems.",
      "key_concept": "Asymptotic Complexity",
      "path": "270questions/270HW1.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment (CSCI 270 Homework #5) presenting three algorithmic problem-solving challenges involving task scheduling, homework point optimization, and balloon shooting strategy, with an emphasis on applying greedy or dynamic programming approaches.",
      "key_concept": "Greedy Algorithm",
      "path": "270questions/270HW5.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment (CSCI 270) containing four dynamic programming and greedy algorithm problems involving binary search trees, potion mixing, road trip gas station optimization, and coin denomination challenges.",
      "key_concept": "Dynamic Programming",
      "path": "270questions/270HW4.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment (CSCI 270) with four algorithmic problem-solving questions focusing on divide-and-conquer techniques, runtime analysis, and algorithm design across various computational scenarios.",
      "key_concept": "Divide-and-Conquer",
      "path": "270questions/270HW6.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment (CSCI 270) containing four algorithmic problem-solving questions related to flow networks, seating arrangements, student program assignments, and student identification.",
      "key_concept": "Flow Networks",
      "path": "270questions/270HW7.pdf",
      "category": "question"
    },
    {
      "summary": "This document presents four complex computational problems (Traveling Hulk, Frequency Allocation, Star Lord, and Triangle-Free Vertex Cover) with detailed descriptions, challenging students to prove their NP-Completeness while incorporating humorous superhero-themed scenarios.",
      "key_concept": "NP-Completeness",
      "path": "270questions/270HW9.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment focusing on computational complexity, specifically exploring problems like k-Flow, NP-completeness, network flow, and various complexity-related true/false questions across graph theory and algorithmic problem solving.",
      "key_concept": "NP-Completeness",
      "path": "270questions/270HW8.pdf",
      "category": "question"
    }
  ],
  "270slides": [
    {
      "summary": "This document provides a comprehensive review of mathematical proofs, runtime analysis techniques, recurrence relations, and amortized analysis, covering topics such as proof by contradiction, induction, the Master Theorem, and analyzing the computational complexity of algorithms like Mergesort and vector operations.",
      "key_concept": "Amortized Runtime",
      "path": "270slides/2-Proofs and Runtime.pdf",
      "category": "slide"
    },
    {
      "summary": "This document explores the Divide and Conquer algorithm design technique, demonstrating its application across various computational problems like counting inversions, matrix multiplication, sequence alignment, and closest points finding, showing how breaking large problems into smaller, manageable subproblems can lead to more efficient algorithmic solutions.",
      "key_concept": "Divide and Conquer",
      "path": "270slides/7-Divide & Conquer.pdf",
      "category": "slide"
    },
    {
      "summary": "This document introduces fundamental concepts in algorithms and theory of computing, exploring problem-solving techniques through examples like the Famous Person Problem and the Gale-Shapley Algorithm, while emphasizing the importance of algorithmic thinking, efficiency, and ethical considerations in computer science.",
      "key_concept": "Algorithms",
      "path": "270slides/1-Introduction.pdf",
      "category": "slide"
    },
    {
      "summary": "This document provides a comprehensive exploration of graph algorithms, focusing on Kruskal's algorithm for minimum spanning trees, Union-Find data structures, sorting algorithms like Radix Sort, graph properties such as bipartiteness and connectivity, and methods for finding topological orderings in directed acyclic graphs (DAGs).",
      "key_concept": "Union-Find Data Structure",
      "path": "270slides/3-Graphs.pdf",
      "category": "slide"
    },
    {
      "summary": "This document explores PSPACE complexity class by discussing space complexity, Savitch's Theorem, PSPACE-Complete problems like True Quantified Boolean Formula (TQBF) and Generalized Geography, and demonstrating how these problems can be understood through strategic game-like scenarios involving variable assignments and graph traversals.",
      "key_concept": "PSPACE",
      "path": "270slides/11-Extra Topics.pdf",
      "category": "slide"
    },
    {
      "summary": "This document discusses proof techniques for two greedy algorithm problems: one involving optimally placing pizza parlors along a road and another involving minimizing pizza preparation and baking time by scheduling pizzas in a specific order.",
      "key_concept": "Greedy Algorithms",
      "path": "270slides/6-Greedy Practice.pdf",
      "category": "slide"
    },
    {
      "summary": "This document provides an in-depth exploration of greedy algorithms, explaining their core principles, demonstrating their application across various problems like interval scheduling, minimum spanning trees, task scheduling, and caching, and showing how to prove their correctness using exchange arguments and inductive reasoning.",
      "key_concept": "Greedy Algorithms",
      "path": "270slides/5-Greedy Algorithms.pdf",
      "category": "slide"
    },
    {
      "summary": "This document explores the concept of NP-completeness by examining various computational problems, demonstrating how different problems can be reduced to each other, and discussing the fundamental question of whether P equals NP.",
      "key_concept": "NP-Complete Problems",
      "path": "270slides/9-P vs. NP.pdf",
      "category": "slide"
    },
    {
      "summary": "This document provides a comprehensive overview of Network Flow algorithms, exploring concepts like Ford-Fulkerson method, residual graphs, max-flow min-cut theorem, and demonstrating polynomial-time reductions of various problems like Bipartite Matching, Circulations, Survey Design, Baseball Elimination, and Project Selection to network flow problems.",
      "key_concept": "Network Flow",
      "path": "270slides/8-Network Flow.pdf",
      "category": "slide"
    },
    {
      "summary": "This document provides a comprehensive overview of Dynamic Programming, explaining its core concept of transforming recursive algorithms with repeated work into efficient iterative solutions by solving subproblems once and storing their results, with detailed explanations and examples across various problem domains like Fibonacci, Weighted Interval Scheduling, Longest Increasing Subsequence, Coin Changing, Sequence Alignment, and RNA Secondary Structure.",
      "key_concept": "Dynamic Programming",
      "path": "270slides/4-Dynamic Programming.pdf",
      "category": "slide"
    },
    {
      "summary": "The document explores the Theory of Computation by demonstrating through proofs and examples that certain computational problems, such as the Halting Problem and the Post Correspondence Problem, are fundamentally unsolvable due to the inherent limitations of algorithms and computational methods.",
      "key_concept": "Halting Problem",
      "path": "270slides/10-Theory of Computation.pdf",
      "category": "slide"
    }
  ]
}