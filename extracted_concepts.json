{
  "270handout": [
    {
      "summary": "This document covers two dynamic programming problems: the coin changing problem and assembly-line scheduling, demonstrating how to break down complex optimization challenges into recursive subproblems with systematic decision-making strategies.",
      "key_concept": "Dynamic Programming",
      "path": "270handout/270handout7 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This document explores various graph problem transformations, including bipartite matching, circulations, survey design, and baseball elimination, demonstrating how different computational problems can be reduced to network flow and solved efficiently in polynomial time.",
      "key_concept": "Network Flow",
      "path": "270handout/270handout21.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses polynomial-time reductions in computer science, specifically demonstrating how problems like Minimum Cut, Bipartite Matching, and Circulations can be solved efficiently by transforming them into network flow problems using algorithmic techniques.",
      "key_concept": "Poly-Time Reductions",
      "path": "270handout/270handout20.pdf",
      "category": "handout"
    },
    {
      "summary": "Dynamic Programming is a problem-solving technique that transforms recursive algorithms into iterative solutions by systematically breaking down complex problems into simpler subproblems and storing intermediate results to avoid redundant computations, illustrated through examples like calculating Fibonacci numbers and solving the Weighted Interval Scheduling problem.",
      "key_concept": "Dynamic Programming",
      "path": "270handout/270handout5 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses a project selection problem where the goal is to find the maximum-valued subset of projects with prerequisites, using graph-based techniques and min-cut analysis to optimize project selection while considering project values and dependencies.",
      "key_concept": "Graph Reduction",
      "path": "270handout/270handout22.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture notes discuss greedy algorithms, focusing on techniques for solving problems like all-pairs shortest paths and interval scheduling, with an emphasis on proving algorithm correctness through inductive reasoning and sequential decision-making.",
      "key_concept": "Greedy Algorithms",
      "path": "270handout/270handout10 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This document explores the concept of NP-completeness by discussing computational complexity, introducing problems like Independent Set and Vertex Cover, and explaining how Circuit-SAT serves as a fundamental NP-complete problem that can potentially reduce all NP problems to a polynomial-time verifiable solution.",
      "key_concept": "NP-Completeness",
      "path": "270handout/270handout23.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses an advanced caching problem where the goal is to minimize cache misses by strategically deciding which items to remove from a cache with a fixed capacity when new items are requested, exploring potential greedy algorithms and their limitations.",
      "key_concept": "Optimal Caching",
      "path": "270handout/270handout15 (2).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture on graph algorithms explores concepts of graph connectivity, directed acyclic graphs (DAGs), topological ordering, and related algorithmic challenges in graph theory.",
      "key_concept": "Graph Connectivity",
      "path": "270handout/270handout4 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture covers several computational complexity problems, including the Travelling Salesman Problem, Subset Sum, and graph coloring challenges like 3-Color and 4-Color, which involve finding optimal solutions or determining the feasibility of specific constraints.",
      "key_concept": "NP-Completeness",
      "path": "270handout/270handout27.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture discusses sequencing problems like the Travelling Salesman Problem and Longest Path, exploring the characteristics of NP-complete problems and highlighting that the complexity of a problem can vary significantly depending on its specific constraints.",
      "key_concept": "NP-Completeness",
      "file": "270handout26.pdf",
      "path": "270handout/270handout26.pdf"
    },
    {
      "summary": "This document discusses two main algorithmic topics: sequence alignment (specifically an efficient method for calculating edit distance between strings using divide-and-conquer) and network flow (exploring the max-flow min-cut problem and the Ford-Fulkerson algorithm for finding augmenting paths in a residual graph).",
      "key_concept": "Network Flow",
      "path": "270handout/270handout18 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture covers advanced computer science topics including the Post Correspondence Problem (PCP), its connection to the Halting Problem, and an exploration of computational complexity classes like PSPACE, with a focus on demonstrating the complexity of problems such as determining the truth of fully quantified Boolean formulas.",
      "key_concept": "Post Correspondence Problem (PCP)",
      "path": "270handout/270handout30.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture discusses NP-Complete problems, focusing on 3-SAT, Independent Set, Set Packing, and k-Clique, while exploring their relationships and the broader implications for understanding computational complexity and the P vs NP problem.",
      "key_concept": "NP-Completeness",
      "path": "270handout/270handout24.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses various NP-complete problems like Independent Set, Set Packing, k-Clique, and Hamiltonian Cycle, highlighting the complexity of these problems and the ongoing challenge of proving whether P equals NP.",
      "key_concept": "NP-Completeness",
      "path": "270handout/270handout25.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses network flow algorithms, specifically the Ford-Fulkerson method for finding the maximum flow in a weighted directed graph, including concepts like residual graphs, augmenting paths, the max-flow min-cut theorem, and capacity-scaling techniques.",
      "key_concept": "Network Flow",
      "path": "270handout/270handout19.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses algorithmic approaches to scheduling tasks with deadlines to minimize lateness and explores optimal caching strategies, focusing on greedy algorithms and proof techniques for minimizing task tardiness and cache misses.",
      "key_concept": "Greedy Algorithms",
      "path": "270handout/270handout14.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses theoretical computer science concepts including 3-D matching, the Halting Problem, the Barber Paradox, and the comparison of countable and uncountable infinite sets, highlighting fundamental challenges in computational theory and mathematical logic.",
      "key_concept": "Halting Problem",
      "path": "270handout/270handout28.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture explores the limits of computation by discussing the Halting Problem, demonstrating through diagonalization and a self-referential paradox that certain computational problems are undecidable, specifically showing that it's impossible to create a universal algorithm that can determine whether an arbitrary computer program will halt or enter an infinite loop.",
      "key_concept": "Undecidability",
      "path": "270handout/270handout29.pdf",
      "category": "handout"
    },
    {
      "summary": "This document covers two dynamic programming algorithms in computer science: sequence alignment (edit distance between strings) and RNA secondary structure prediction, both focusing on efficiently solving optimization problems by breaking them down into smaller subproblems and using recursive techniques.",
      "key_concept": "Dynamic Programming",
      "path": "270handout/270handout8 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture notes discuss the Longest Increasing Subsequence (LIS) problem, exploring recursive approaches to finding the longest increasing subsequence in a given sequence of numbers, and briefly touching on polynomial runtime algorithms and primality testing.",
      "key_concept": "Dynamic Programming",
      "path": "270handout/270handout6.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture covers amortized runtime analysis, exploring the performance characteristics of list operations, binary counting, and minimum spanning tree algorithms like Kruskal's and Prim's, with a focus on understanding the average-case computational complexity of various algorithmic approaches.",
      "key_concept": "Amortized Runtime Analysis",
      "path": "270handout/270handout2.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses common proof errors when attempting to prove the correctness of Prim's Algorithm, and provides a detailed, step-by-step correct proof methodology for demonstrating that the algorithm produces an optimal minimum spanning tree.",
      "key_concept": "Proof by Induction",
      "path": "270handout/270handout12.pdf",
      "category": "handout"
    },
    {
      "summary": "This document describes a classroom exercise for CSCI 270 where students practice creating and grading proofs for a greedy algorithm that forms study groups with a specific composition of students and course participants (CPs).",
      "key_concept": "Proof Techniques",
      "path": "270handout/270handout13.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture introduces fundamental computer science concepts including algorithm design, problem-solving strategies, the famous person problem, stable matching algorithms, and the ethical considerations of algorithmic decision-making, with a focus on developing systematic approaches to solving computational challenges.",
      "key_concept": "Algorithms",
      "path": "270handout/270handout1.pdf",
      "category": "handout"
    },
    {
      "summary": "This document discusses greedy algorithm design and proof techniques, specifically focusing on interval scheduling and minimum spanning tree algorithms, demonstrating how to prove the correctness of greedy algorithms using inductive reasoning and exchange arguments.",
      "key_concept": "Greedy Algorithms",
      "path": "270handout/270handout11.pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture notes discuss two dynamic programming algorithms: the Subset Sum problem for determining if a subset of integers can sum to a target value, and the Shortest Path problem (Bellman-Ford algorithm) for finding the shortest path in a graph with no negative weight cycles.",
      "key_concept": "Dynamic Programming",
      "path": "270handout/270handout9 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture notes document covers three divide and conquer algorithms: All Pairs Shortest Paths, Integer Multiplication, and Closest Points on a Plane, exploring their recursive strategies, base cases, recurrence relations, and computational complexities.",
      "key_concept": "Divide and Conquer",
      "path": "270handout/270handout17 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture on Divide and Conquer introduces the algorithmic technique of solving problems by recursively splitting them into smaller, independent subproblems, discussing its application in algorithms like MergeSort and QuickSort, and exploring the Master Theorem for analyzing recurrence relations.",
      "key_concept": "Divide and Conquer",
      "path": "270handout/270handout16 (1).pdf",
      "category": "handout"
    },
    {
      "summary": "This lecture notes document covers Union-Find data structures, Kruskal's algorithm for minimum spanning trees, sorting algorithm complexity (including comparison-based sorting lower bounds), and graph theory concepts like bipartite graphs.",
      "key_concept": "Union-Find",
      "path": "270handout/270handout3 (1).pdf",
      "category": "handout"
    }
  ],
  "270questions": [
    {
      "summary": "This is a computer science homework assignment (CSCI 270) containing four algorithmic problem-solving challenges involving graph partitioning, dynamic programming for frog hopping, palindrome substring detection, and a game theory problem with a linked list.",
      "key_concept": "Dynamic Programming",
      "path": "270questions/270HW3.pdf",
      "category": "question"
    },
    {
      "summary": "This homework assignment for CSCI 270 covers advanced data structure problems involving stacks, queues, amortized analysis, and sorting algorithms, with four specific algorithmic challenges related to stack/queue operations, runtime complexity, and k-sorted array sorting.",
      "key_concept": "Data Structures",
      "path": "270questions/270HW2.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment (CSCI 270) containing four problems that cover topics in algorithm analysis, asymptotic complexity, mathematical proofs by contradiction and induction, involving function comparisons, big O notation, and graph/location connectivity problems.",
      "key_concept": "Asymptotic Complexity",
      "path": "270questions/270HW1.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment (CSCI 270 Homework #5) presenting three algorithmic problem-solving challenges involving task scheduling, homework point optimization, and balloon shooting strategy, with an emphasis on applying greedy or dynamic programming approaches.",
      "key_concept": "Greedy Algorithm",
      "path": "270questions/270HW5.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment (CSCI 270) containing four dynamic programming and greedy algorithm problems involving binary search trees, potion mixing, road trip gas station optimization, and coin denomination challenges.",
      "key_concept": "Dynamic Programming",
      "path": "270questions/270HW4.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment (CSCI 270) with four algorithmic problem-solving questions focusing on divide-and-conquer techniques, runtime analysis, and algorithm design across various computational scenarios.",
      "key_concept": "Divide-and-Conquer",
      "path": "270questions/270HW6.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment (CSCI 270) containing four algorithmic problem-solving questions related to flow networks, seating arrangements, student program assignments, and student identification.",
      "key_concept": "Flow Networks",
      "path": "270questions/270HW7.pdf",
      "category": "question"
    },
    {
      "summary": "This document presents four complex computational problems (Traveling Hulk, Frequency Allocation, Star Lord, and Triangle-Free Vertex Cover) with detailed descriptions, challenging students to prove their NP-Completeness while incorporating humorous superhero-themed scenarios.",
      "key_concept": "NP-Completeness",
      "path": "270questions/270HW9.pdf",
      "category": "question"
    },
    {
      "summary": "This is a computer science homework assignment focusing on computational complexity, specifically exploring problems like k-Flow, NP-completeness, network flow, and various complexity-related true/false questions across graph theory and algorithmic problem solving.",
      "key_concept": "NP-Completeness",
      "path": "270questions/270HW8.pdf",
      "category": "question"
    }
  ],
  "270slides": [
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0x95 in position 16: invalid start byte",
      "key_concept": "",
      "file": "7-Divide & Conquer.pptx",
      "path": "270slides/7-Divide & Conquer.pptx"
    },
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0x84 in position 14: invalid start byte",
      "key_concept": "",
      "file": "8-Network Flow.pptx",
      "path": "270slides/8-Network Flow.pptx"
    },
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0xbf in position 16: invalid start byte",
      "key_concept": "",
      "file": "3-Graphs.pptx",
      "path": "270slides/3-Graphs.pptx"
    },
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0xba in position 14: invalid start byte",
      "key_concept": "",
      "file": "5-Greedy Algorithms.pptx",
      "path": "270slides/5-Greedy Algorithms.pptx"
    },
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0xe2 in position 14: invalid continuation byte",
      "key_concept": "",
      "file": "4-Dynamic Programming.pptx",
      "path": "270slides/4-Dynamic Programming.pptx"
    },
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0xdd in position 15: invalid continuation byte",
      "key_concept": "",
      "file": "6-Greedy Practice.pptx",
      "path": "270slides/6-Greedy Practice.pptx"
    },
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0xf7 in position 16: invalid start byte",
      "key_concept": "",
      "file": "10-Theory of Computation.pptx",
      "path": "270slides/10-Theory of Computation.pptx"
    },
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0xdc in position 14: invalid continuation byte",
      "key_concept": "",
      "file": "2-Proofs and Runtime.pptx",
      "path": "270slides/2-Proofs and Runtime.pptx"
    },
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0xce in position 15: invalid continuation byte",
      "key_concept": "",
      "file": "1-Introduction.pptx",
      "path": "270slides/1-Introduction.pptx"
    },
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0xaa in position 14: invalid start byte",
      "key_concept": "",
      "file": "11-Extra Topics.pptx",
      "path": "270slides/11-Extra Topics.pptx"
    },
    {
      "summary": "Error reading file: 'utf-8' codec can't decode byte 0x84 in position 14: invalid start byte",
      "key_concept": "",
      "file": "9-P vs. NP.pptx",
      "path": "270slides/9-P vs. NP.pptx"
    }
  ]
}