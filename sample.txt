# Introduction to Greedy Algorithms

Greedy algorithms are a class of algorithms that make locally optimal choices at each step with the hope of finding a global optimum. In many problems, a greedy strategy does not usually produce an optimal solution, but for some specific problems, it can be proven that a greedy strategy is indeed optimal.

## When to Use Greedy Algorithms

Greedy algorithms are typically used for optimization problems where:
1. There is a clear objective function to maximize or minimize.
2. The problem has the "greedy-choice property," meaning that a global optimum can be reached by making locally optimal choices.
3. The problem has "optimal substructure," meaning that the optimal solution to the problem contains optimal solutions to its subproblems.

## Examples of Greedy Algorithms

### Minimum Spanning Tree (MST)
Both Kruskal's and Prim's algorithms for finding the MST of a graph are greedy algorithms. At each step:
- Kruskal's algorithm adds the next lowest-weight edge that doesn't create a cycle.
- Prim's algorithm adds the lowest-weight edge that connects a new vertex to the growing tree.

### Huffman Coding
Huffman coding is a greedy algorithm used for data compression. It assigns variable-length codes to input characters, with shorter codes for more frequent characters, resulting in optimal prefix codes.

### Activity Selection Problem
The activity selection problem involves selecting the maximum number of activities that can be performed by a single person, assuming that the person can only work on a single activity at a time. A greedy approach sorts activities by finish time and selects activities that finish earliest.

## Advantages and Limitations

Advantages:
- Simple and intuitive
- Often easy to implement
- Generally efficient

Limitations:
- May not always find the optimal solution
- Can be difficult to prove correctness
- Requires careful problem analysis to determine if a greedy approach will work

## Common Pitfalls

A common mistake is applying greedy algorithms to problems where they don't guarantee optimal solutions. For example, the classic knapsack problem (with fractional values allowed) can be solved optimally with a greedy approach, but the 0-1 knapsack problem (where items cannot be divided) cannot be solved optimally with a simple greedy strategy.

## Conclusion

Greedy algorithms are powerful tools when applied to appropriate problems. Understanding when to use them and recognizing their limitations is essential for efficient algorithm design and implementation. 