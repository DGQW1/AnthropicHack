{
  "270handout": [
    {
      "summary": "This document covers dynamic programming solutions for coin changing and assembly-line scheduling optimization problems.",
      "key_concept": "Dynamic Programming",
      "file": "270handout7 (1).pdf",
      "path": "270handout/270handout7 (1).pdf"
    },
    {
      "summary": "This document explores reducing various graph problems like bipartite matching and circulations to network flow algorithms.",
      "key_concept": "Network Flow",
      "file": "270handout21.pdf",
      "path": "270handout/270handout21.pdf"
    },
    {
      "summary": "This document explores polynomial-time reductions of network flow problems like Minimum Cut, Bipartite Matching, and Circulations.",
      "key_concept": "Poly-Time Reductions",
      "file": "270handout20.pdf",
      "path": "270handout/270handout20.pdf"
    },
    {
      "summary": "Dynamic programming transforms recursive algorithms into efficient iterative solutions by storing and reusing intermediate computational results.",
      "key_concept": "Dynamic Programming",
      "file": "270handout5 (1).pdf",
      "path": "270handout/270handout5 (1).pdf"
    },
    {
      "summary": "This lecture discusses a project selection problem involving finding the maximum-valued subset of projects with complex prerequisites.",
      "key_concept": "Graph Reduction",
      "file": "270handout22.pdf",
      "path": "270handout/270handout22.pdf"
    },
    {
      "summary": "This lecture covers greedy algorithms, focusing on all-pairs shortest paths and interval scheduling, with an emphasis on proving algorithmic correctness.",
      "key_concept": "Greedy Algorithms",
      "file": "270handout10 (1).pdf",
      "path": "270handout/270handout10 (1).pdf"
    },
    {
      "summary": "This lecture explores NP-completeness, focusing on computational complexity, verifiability of problems, and the relationship between P and NP classes.",
      "key_concept": "NP-Completeness",
      "file": "270handout23.pdf",
      "path": "270handout/270handout23.pdf"
    },
    {
      "summary": "This document analyzes optimal caching strategies, exploring how to minimize cache misses when requests are known in advance.",
      "key_concept": "Optimal Caching",
      "file": "270handout15 (2).pdf",
      "path": "270handout/270handout15 (2).pdf"
    },
    {
      "summary": "This lecture covers graph connectivity, directed acyclic graphs (DAGs), and topological ordering algorithms.",
      "key_concept": "Graph Connectivity",
      "file": "270handout4 (1).pdf",
      "path": "270handout/270handout4 (1).pdf"
    },
    {
      "summary": "This lecture covers computational complexity problems involving graph coloring, routing, and subset selection algorithms.",
      "key_concept": "NP-Completeness",
      "file": "270handout27.pdf",
      "path": "270handout/270handout27.pdf"
    },
    {
      "summary": "This lecture explores NP-complete sequencing problems like Travelling Salesman Problem and discusses characteristics of computational complexity.",
      "key_concept": "NP-completeness",
      "file": "270handout26.pdf",
      "path": "270handout/270handout26.pdf"
    },
    {
      "summary": "This lecture covers sequence alignment algorithms and network flow problems, focusing on edit distance and maximum flow techniques.",
      "key_concept": "Network Flow",
      "file": "270handout18 (1).pdf",
      "path": "270handout/270handout18 (1).pdf"
    },
    {
      "summary": "This lecture covers the Post Correspondence Problem, complexity classes like PSPACE, and undecidability in computational theory.",
      "key_concept": "Post Correspondence Problem (PCP)",
      "file": "270handout30.pdf",
      "path": "270handout/270handout30.pdf"
    },
    {
      "summary": "This lecture explores NP-Complete problems like 3-SAT, Independent Set, Set Packing, and k-Clique, highlighting computational complexity.",
      "key_concept": "NP-Completeness",
      "file": "270handout24.pdf",
      "path": "270handout/270handout24.pdf"
    },
    {
      "summary": "This lecture explores various NP-complete problems like Independent Set, Set Packing, k-Clique, and Hamiltonian Cycle.",
      "key_concept": "NP-Completeness",
      "file": "270handout25.pdf",
      "path": "270handout/270handout25.pdf"
    },
    {
      "summary": "Network flow algorithms like Ford-Fulkerson solve maximum flow problems by finding augmenting paths in residual graphs.",
      "key_concept": "Network Flow",
      "file": "270handout19.pdf",
      "path": "270handout/270handout19.pdf"
    },
    {
      "summary": "This document discusses scheduling algorithms and optimal caching strategies, focusing on minimizing task lateness and cache misses.",
      "key_concept": "Greedy Algorithms",
      "file": "270handout14.pdf",
      "path": "270handout/270handout14.pdf"
    },
    {
      "summary": "This lecture covers advanced computer science topics including 3-D matching, the Halting Problem, and countable versus uncountable sets.",
      "key_concept": "Halting Problem",
      "file": "270handout28.pdf",
      "path": "270handout/270handout28.pdf"
    },
    {
      "summary": "The Halting Problem demonstrates fundamental computational limits through a proof of undecidability using diagonalization and self-referential logic.",
      "key_concept": "Undecidability",
      "file": "270handout29.pdf",
      "path": "270handout/270handout29.pdf"
    },
    {
      "summary": "This document covers dynamic programming algorithms for sequence alignment and RNA secondary structure prediction using recursive techniques.",
      "key_concept": "Dynamic Programming",
      "file": "270handout8 (1).pdf",
      "path": "270handout/270handout8 (1).pdf"
    },
    {
      "summary": "This lecture explores the Longest Increasing Subsequence problem, discussing recursive approaches and computational complexity.",
      "key_concept": "Dynamic Programming",
      "file": "270handout6.pdf",
      "path": "270handout/270handout6.pdf"
    },
    {
      "summary": "This lecture covers amortized runtime analysis, list operations, binary counting, and minimum spanning tree algorithms like Kruskal's and Prim's.",
      "key_concept": "Amortized Runtime Analysis",
      "file": "270handout2.pdf",
      "path": "270handout/270handout2.pdf"
    },
    {
      "summary": "This document discusses common proof errors when attempting to prove the correctness of Prim's Algorithm for finding a minimum spanning tree.",
      "key_concept": "Proof by Induction",
      "file": "270handout12.pdf",
      "path": "270handout/270handout12.pdf"
    },
    {
      "summary": "In a CSSI 270 lecture, students practice proving the correctness of a greedy algorithm for forming study groups.",
      "key_concept": "Proof Techniques",
      "file": "270handout13.pdf",
      "path": "270handout/270handout13.pdf"
    },
    {
      "summary": "This lecture introduces algorithmic problem-solving techniques and ethical considerations in computer science, focusing on famous person and stable matching problems.",
      "key_concept": "Algorithms",
      "file": "270handout1.pdf",
      "path": "270handout/270handout1.pdf"
    },
    {
      "summary": "This document discusses proving the correctness of greedy algorithms like Interval Scheduling and Minimum Spanning Trees using inductive reasoning.",
      "key_concept": "Greedy Algorithms",
      "file": "270handout11.pdf",
      "path": "270handout/270handout11.pdf"
    },
    {
      "summary": "This lecture covers dynamic programming approaches for solving the Subset Sum problem and finding shortest paths in graphs.",
      "key_concept": "Dynamic Programming",
      "file": "270handout9 (1).pdf",
      "path": "270handout/270handout9 (1).pdf"
    },
    {
      "summary": "This lecture covers divide and conquer techniques for solving problems like all-pairs shortest paths, integer multiplication, and closest points.",
      "key_concept": "Divide and Conquer",
      "file": "270handout17 (1).pdf",
      "path": "270handout/270handout17 (1).pdf"
    },
    {
      "summary": "Divide and Conquer is a runtime improvement technique that solves problems by recursively splitting, solving, and combining subproblems.",
      "key_concept": "Divide and Conquer",
      "file": "270handout16 (1).pdf",
      "path": "270handout/270handout16 (1).pdf"
    },
    {
      "summary": "This lecture covers Union-Find data structures, Kruskal's algorithm for minimum spanning trees, sorting complexity, and graph theory concepts.",
      "key_concept": "Union-Find",
      "file": "270handout3 (1).pdf",
      "path": "270handout/270handout3 (1).pdf"
    }
  ],
  "270questions": [
    {
      "summary": "This is a computer science homework assignment covering graph algorithms, dynamic programming, and problem-solving strategies across four challenging problems.",
      "key_concept": "Dynamic Programming",
      "file": "270HW3.pdf",
      "path": "270questions/270HW3.pdf"
    },
    {
      "summary": "This homework assignment covers stack operations, amortized runtime analysis, queue implementation, and k-sorted array sorting algorithms.",
      "key_concept": "Data Structures",
      "file": "270HW2.pdf",
      "path": "270questions/270HW2.pdf"
    },
    {
      "summary": "A computer science homework assignment covering asymptotic complexity, big O notation, and mathematical proofs for various algorithmic problems.",
      "key_concept": "Asymptotic Complexity",
      "file": "270HW1.pdf",
      "path": "270questions/270HW1.pdf"
    },
    {
      "summary": "A computer science homework assignment presenting three algorithmic problem-solving challenges involving task scheduling and optimization.",
      "key_concept": "Greedy Algorithm",
      "file": "270HW5.pdf",
      "path": "270questions/270HW5.pdf"
    },
    {
      "summary": "This is a computer science homework assignment covering dynamic programming and greedy algorithm problems involving binary search trees, potion mixing, road trips, and coin selection.",
      "key_concept": "Dynamic Programming",
      "file": "270HW4.pdf",
      "path": "270questions/270HW4.pdf"
    },
    {
      "summary": "This homework assignment covers advanced algorithmic problem-solving techniques involving divide-and-conquer strategies across four complex computational challenges.",
      "key_concept": "Divide-and-Conquer",
      "file": "270HW6.pdf",
      "path": "270questions/270HW6.pdf"
    },
    {
      "summary": "A computer science homework assignment covering flow networks, seating arrangements, student assignments, and student identification algorithms.",
      "key_concept": "Flow Networks",
      "file": "270HW7.pdf",
      "path": "270questions/270HW7.pdf"
    },
    {
      "summary": "This homework assignment requires proving the NP-Completeness of four complex computational problems involving graph traversal and constraints.",
      "key_concept": "NP-Completeness",
      "file": "270HW9.pdf",
      "path": "270questions/270HW9.pdf"
    },
    {
      "summary": "This homework assignment explores computational complexity, NP-completeness, and various graph and flow problems across multiple problem sets.",
      "key_concept": "NP-Completeness",
      "file": "270HW8.pdf",
      "path": "270questions/270HW8.pdf"
    }
  ],
  "270slides": [
    {
      "summary": "This document covers mathematical proofs, runtime analysis techniques, recurrence relations, and amortized complexity in computer science.",
      "key_concept": "Amortized Runtime",
      "file": "2-Proofs and Runtime.pdf",
      "path": "270slides/2-Proofs and Runtime.pdf"
    },
    {
      "summary": "Divide and Conquer is a problem-solving technique that breaks complex problems into smaller, independent subproblems to improve algorithmic efficiency.",
      "key_concept": "Divide and Conquer",
      "file": "7-Divide & Conquer.pdf",
      "path": "270slides/7-Divide & Conquer.pdf"
    },
    {
      "summary": "An introduction to algorithm design and problem-solving techniques, exploring famous person identification and stable matching algorithms.",
      "key_concept": "Algorithms",
      "file": "1-Introduction.pdf",
      "path": "270slides/1-Introduction.pdf"
    },
    {
      "summary": "This document comprehensively explores graph algorithms, including Kruskal's algorithm, Union-Find data structure, sorting techniques, and graph properties.",
      "key_concept": "Union-Find Data Structure",
      "file": "3-Graphs.pdf",
      "path": "270slides/3-Graphs.pdf"
    },
    {
      "summary": "PSPACE explores computational complexity through space-bounded problems, focusing on games and quantified Boolean formulas.",
      "key_concept": "PSPACE",
      "file": "11-Extra Topics.pdf",
      "path": "270slides/11-Extra Topics.pdf"
    },
    {
      "summary": "This document discusses proof techniques for greedy algorithms in solving optimization problems involving pizza parlor placement and pizza preparation scheduling.",
      "key_concept": "Greedy Algorithms",
      "file": "6-Greedy Practice.pdf",
      "path": "270slides/6-Greedy Practice.pdf"
    },
    {
      "summary": "Greedy algorithms solve optimization problems by making locally optimal choices at each step, with proofs using exchange arguments.",
      "key_concept": "Greedy Algorithms",
      "file": "5-Greedy Algorithms.pdf",
      "path": "270slides/5-Greedy Algorithms.pdf"
    },
    {
      "summary": "This document explores NP-completeness, explaining how various computational problems are related and demonstrating reductions between NP-complete problems.",
      "key_concept": "NP-Complete Problems",
      "file": "9-P vs. NP.pdf",
      "path": "270slides/9-P vs. NP.pdf"
    },
    {
      "summary": "Network flow algorithms explore techniques for maximizing data flow through a directed graph by finding augmenting paths and minimum cuts.",
      "key_concept": "Network Flow",
      "file": "8-Network Flow.pdf",
      "path": "270slides/8-Network Flow.pdf"
    },
    {
      "summary": "Dynamic programming transforms recursive algorithms into efficient iterative solutions by solving subproblems once and storing their results.",
      "key_concept": "Dynamic Programming",
      "file": "4-Dynamic Programming.pdf",
      "path": "270slides/4-Dynamic Programming.pdf"
    },
    {
      "summary": "The document explores computational limits by proving the Halting Problem is undecidable through set theory and proof by contradiction.",
      "key_concept": "Halting Problem",
      "file": "10-Theory of Computation.pdf",
      "path": "270slides/10-Theory of Computation.pdf"
    }
  ]
}